<template>
  <div class="w-full">
    <h1 class="text-2xl font-bold mb-4">Selector de Ubicación</h1>

    <!-- Display selected location info -->
    <div v-if="selectedLocation.position.lat" class="mb-4 p-4 bg-gray-100 rounded-lg">
      <h3 class="font-semibold">Ubicación Seleccionada:</h3>
      <p class="text-sm text-gray-600">{{ selectedLocation.address }}</p>
      <p class="text-xs text-gray-500">
        Lat: {{ selectedLocation.position.lat?.toFixed(6) }},
        Lng: {{ selectedLocation.position.lng?.toFixed(6) }}
      </p>
    </div>

    <LMap ref="mapRef" style="height: 500px; width: 100%;" :zoom="zoom" :center="mapCenter" :use-global-leaflet="false"
      @dblclick="onMapClick">
      <LTileLayer :url="tileProvider.url" :attribution="tileProvider.attribution" />

      <!-- Search Control -->
      <div class="leaflet-top leaflet-left" style="margin-top: 10px; margin-left: 10px;">
        <div class="leaflet-control leaflet-bar">
          <input v-model="searchQuery" placeholder="Buscar ubicación..." class="px-3 py-2 border rounded-md text-sm"
            style="width: 200px;" @keyup.enter="searchLocation">
          <button class="ml-1 px-3 py-2 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600"
            @click="searchLocation">
            Buscar
          </button>
        </div>
      </div>

      <!-- Location Marker -->
      <LMarker v-if="markerPosition.lat && markerPosition.lng" :lat-lng="markerPosition" :draggable="true"
        @dragstart="isDragging = true" @dragend="onMarkerDragEnd">
        <LTooltip :options="{ permanent: true }">
          <!-- eslint-disable-next-line vue/no-v-html -->
          <div v-html="tooltipContent" />
        </LTooltip>
      </LMarker>
    </LMap>
  </div>
</template>

<script setup lang="ts">
import { OpenStreetMapProvider } from 'leaflet-geosearch'

// Types
interface Position {
  lat: number
  lng: number
}

interface LocationData {
  position: Position
  address: string
}

interface TileProvider {
  url: string
  attribution: string
}

// Reactive state
const mapRef = ref(null)
const searchQuery = ref('')
const isDragging = ref(false)
const isLoading = ref(false)
const userLocation = ref<Position>({ lat: 0, lng: 0 })
const markerPosition = ref<Position>({ lat: 0, lng: 0 })
const selectedLocation = ref<LocationData>({
  position: { lat: 0, lng: 0 },
  address: ''
})

// Default configuration
const defaultLocation: Position = {
  lat: 19.4326, // Mexico City as default
  lng: -99.1332
}

const tileProvider: TileProvider = {
  url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
}

const zoom = ref(13)

// Search provider
const searchProvider = new OpenStreetMapProvider()

// Computed properties
const mapCenter = computed((): [number, number] => {
  if (markerPosition.value.lat && markerPosition.value.lng) {
    return [markerPosition.value.lat, markerPosition.value.lng]
  }
  if (userLocation.value.lat && userLocation.value.lng) {
    return [userLocation.value.lat, userLocation.value.lng]
  }
  return [defaultLocation.lat, defaultLocation.lng]
})

const tooltipContent = computed(() => {
  if (isDragging.value) return '...'
  if (isLoading.value) return 'Cargando...'

  const address = selectedLocation.value.address || 'Dirección no encontrada'
  const lat = markerPosition.value.lat?.toFixed(6) || '0'
  const lng = markerPosition.value.lng?.toFixed(6) || '0'

  return `<strong>${address.replace(',', '<br/>')}</strong><hr/><strong>Lat:</strong> ${lat}<br/><strong>Lng:</strong> ${lng}`
})

// Methods
const getUserPosition = async (): Promise<void> => {
  return new Promise((resolve) => {
    if (!navigator.geolocation) {
      console.warn('Geolocation is not supported by this browser.')
      resolve()
      return
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        userLocation.value = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        }

        // Si no hay marcador, colocar uno en la ubicación del usuario
        if (!markerPosition.value.lat && !markerPosition.value.lng) {
          markerPosition.value = { ...userLocation.value }
        }

        resolve()
      },
      (error) => {
        console.warn('Error getting user location:', error)
        resolve()
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 600000
      }
    )
  })
}

const getAddress = async (position: Position): Promise<string> => {
  isLoading.value = true
  let address = 'Dirección no encontrada'

  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${position.lat}&lon=${position.lng}`
    )

    if (response.ok) {
      const data = await response.json()
      address = data.display_name || address
    }
  } catch (error) {
    console.error('Reverse geocoding error:', error)
  } finally {
    isLoading.value = false
  }

  return address
}

const updateSelectedLocation = async (position: Position): Promise<void> => {
  const address = await getAddress(position)
  selectedLocation.value = {
    position: { ...position },
    address
  }
}

const onMapClick = async (event: { latlng: Position }): Promise<void> => {
  const { lat, lng } = event.latlng
  markerPosition.value = { lat, lng }
  await updateSelectedLocation({ lat, lng })
}

const onMarkerDragEnd = async (event: { target: { getLatLng: () => Position } }): Promise<void> => {
  isDragging.value = false
  const { lat, lng } = event.target.getLatLng()
  markerPosition.value = { lat, lng }
  await updateSelectedLocation({ lat, lng })
}

const searchLocation = async (): Promise<void> => {
  if (!searchQuery.value.trim()) return

  try {
    isLoading.value = true
    const results = await searchProvider.search({ query: searchQuery.value })

    if (results && results.length > 0) {
      const result = results[0]
      if (result) {
        const position = { lat: result.y, lng: result.x }

        markerPosition.value = position
        await updateSelectedLocation(position)

        // Center map on search result
        zoom.value = 16
      }
    }
  } catch (error) {
    console.error('Search error:', error)
  } finally {
    isLoading.value = false
  }
}

// Watch for marker position changes
watch(markerPosition, async (newPosition) => {
  if (newPosition.lat && newPosition.lng) {
    await updateSelectedLocation(newPosition)
  }
}, { deep: true })

// Lifecycle
onMounted(async () => {
  await getUserPosition()
})

// Expose the selected location for parent components
defineExpose({
  selectedLocation: readonly(selectedLocation)
})
</script>

<style scoped>
.leaflet-control {
  background: white;
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
}

.leaflet-bar {
  display: flex;
  align-items: center;
}
</style>